<!-- SYNC IMPACT REPORT
     Version change: 1.0.4 → 1.0.5 (patch update for adding documentation principle)
     Modified sections: Section 7 (Code style) - removed comments requirement, Section 15 (New Documentation principle)
     Added sections: Section 15 (Документирование кода)
     Templates requiring updates:
       - .specify/templates/plan-template.md: ⚠ pending (need to check "Constitution Check" rules)
       - .specify/templates/spec-template.md: ⚠ pending (need to check scope/requirements alignment)
       - .specify/templates/tasks-template.md: ⚠ pending (need to check task categorization)
     Follow-up TODOs: None
-->
# vsservice Constitution

## Core Principles

### 1. Основной стек технологий
Языки и фреймворки: Go (версия 1.24), Uber fx для внедрения зависимостей, Google gRPC для межсервисного взаимодействия, grpc-gateway для преобразования gRPC вызовов в REST API. Используются Uber zap для логирования, go.mongodb.org/mongo-driver v2 для MongoDB, MinIO (S3-совместимое) для объектного хранилища, github.com/golang-jwt/jwt/v5 для JWT аутентификации, github.com/kelseyhightower/envconfig + github.com/joho/godotenv для конфигурации, google.golang.org/protobuf для протобуферов. Библиотеки: buf для сборки протобуферов, github.com/jmattheis/goverter для конвертации структур, github.com/hashicorp/go-retryablehttp для HTTP клиента с повторными попытками, github.com/samber/lo и github.com/google/uuid для утилит.

### 2. Архитектура и структура проекта
Микросервисная архитектура: набор сервисов, объединенных под управлением одного gRPC-сервера с HTTP-шлюзом. Two-server architecture: основной gRPC сервер и HTTP-шлюз для REST API. Uber fx управляет жизненным циклом компонентов, используя fx.Provide и fx.Invoke для связывания компонентов. Каждый новый функционал должен быть реализован как отдельный сервис с именами пакетов, отражающими доменную область. Новый код не должен нарушать изолированность сервисов, все зависимости между сервисами должны происходить через интерфейсы.

### 3. Работа с gRPC и REST API
Определения API находятся в `/proto/` в формате protobuf, используется buf для управления протобуферами. Для каждого сервиса есть отдельный каталог в `/proto/`, gRPC сервисы автоматически экспортируются как REST API через http annotations. Протобуферы генерируют код в `/gen/`, конвертация между типами осуществляется через goverter с мапперами, определяемыми с помощью аннотаций goverter в интерфейсах.

### 4. Управление данными
Все MongoDB документы наследуются от `mongo.Model` с полями `Id` (bson.ObjectID), `CreatedAt`, `UpdatedAt`. Структура: доменные модели в `/internal/*/model/`, DTO в `/internal/*/internal/dto/`. Интерфейс репозитория определяется в `/internal/*/internal/service/interface.go`, реализация в `/internal/*/internal/repository/mongo/`. Уровни преобразования данных: gRPC protobuf models → внутренние доменные модели → MongoDB DTO → HTTP API DTO.

### 5. Аутентификация и авторизация
Используется аутентификация на основе JWT с gRPC интерцепторами `interceptor.Auth.Unary()` и `interceptor.Auth.Stream()`. Проверка токена осуществляется через `interceptor.jwtManager.Verify()`, userID и claims добавляются в контекст запроса. Авторизация на уровне методов с использованием областей через интерфейс Scoper, проверка областей в `interceptor.authorize()`.

## Configuration Management

### 6. Конфигурация
Конфигурация управляется через структуру `/internal/pkg/config/config.go`, переменные окружения маппятся через envconfig, .env файлы поддерживаются как fallback через godotenv. Чувствительные данные монтируются из файлов, а не передаются как переменные окружения.

## Code Style and Practices

### 7. Code style
Приоритетно писать код следуя Go idioms и best practices (Go Way). Использовать camelCase для экспортируемых полей protobuf и snake_case для внутреннего кода. Всегда проверять и пропагейтить ошибки. Использовать структурированное логирование с zap. Использовать context для отмены и передачи метаданных. Инкапсуляция валидации в доменных моделях, чистые доменные методы инкапсулируют бизнес-логику, изолированность сервисов, каждый компонент должен быть легко тестопригодным через интерфейсы.

### 8. Документирование кода
Для документирования кода в проекте используются только комментарии-документации (go doc comments): 
1. Каждый пакет должен иметь документацию в начале файла
2. Все публичные интерфейсы, функции, структуры и методы должны быть задокументированы
3. Публичные и в редких случаях непубличные константы и поля должны быть задокументированы для прояснения их назначения
4. Внутренние (не публичные) функции и методы документируются только при необходимости для прояснения сложной логики
Комментарии в теле кода (inline comments) используются только при необходимости пояснить нетривиальную логику. Обычные комментарии (не документация) использовать не рекомендуется - код должен быть самодокументируемым.

### 9. Избегать большой вложенности, следовать KISS
Избегать глубокой вложенности условных операторов, циклов и функций. Следовать принципу KISS (Keep It Simple, Stupid) - максимальная простота решений, избегать преждевременной оптимизации и усложнения кода. Каждая функция должна решать одну задачу, каждый файл должен содержать логически связанную функциональность.

### 10. API Design following Google AIP simplified variant
Дизайн API должен следовать принципам Google AIP (API Improvement Proposals), но в упрощенном варианте. Это включает: последовательное именование ресурсов и методов, стандартизированные паттерны URL, согласованные соглашения об именовании полей, иерархическую структуру ресурсов, стандартные наборы операций (create, get, list, update, delete). При этом следует избегать излишней сложности оригинальных AIP и адаптировать подходы под конкретные нужды проекта.

### 11. Особые практики
Модульные тесты покрывают бизнес-логику сервисов, интерфейсы позволяют легко создавать mock-реализации для тестирования, интеграционные тесты проверяют взаимодействие между компонентами. Использовать стандартные Go линтеры (golangci-lint), все изменения проходят ревью перед мержем, проверка безопасности и качества кода. Структурированное логирование через zap с полями для фильтрации, правильное использование уровней логов, включать идентификаторы запросов и пользователей в логи. Проверка аутентификации для всех gRPC методов, проверка авторизации областей в интерцепторе, валидация входных данных на уровне сервисов, использование параметризованных запросов к MongoDB.

### 12. Безопасность и защита от атак
1. **Rate Limiting**: Реализовать ограничение частоты запросов (rate limiting) для защиты от DDoS-атак и чрезмерного использования API. Использовать библиотеки вроде `golang.org/x/time/rate` для управления лимитами.
2. **Валидация входных данных**: Все входные данные должны проходить строгую валидацию, включая проверку типов, диапазонов, форматов и размеров. Использовать валидационные структуры и библиотеки вроде `github.com/go-playground/validator/v10`.
3. **Защита от XSS (Cross-Site Scripting)**: Все пользовательские данные, возвращаемые в API, должны быть должным образом экранированы перед отображением в веб-интерфейсах.
4. **Защита от SQL/NoSQL-инъекций**: При работе с MongoDB использовать параметризованные запросы и валидацию входных данных, избегать построения запросов строковой конкатенацией.
5. **CORS-политики**: Правильно настроенные CORS-заголовки, ограничивающие доступ к API только разрешённым доменам.
6. **Защита от CSRF (Cross-Site Request Forgery)**: Для веб-интерфейсов, если они будут добавлены, реализовать CSRF-токены и проверки.
7. **Ограничение размера загружаемых файлов**: Реализовать ограничения на размер загружаемых файлов и проверку типов файлов (например, изображений) для предотвращения атак через загрузку вредоносных файлов.
8. **Обфускация идентификаторов**: Использовать неочевидные идентификаторы (UUID, случайные строки) вместо последовательных чисел для защиты от enumeration атак.
9. **Контроль доступа к ресурсам**: Проверка прав доступа к каждому ресурсу, возвращение одинаковых сообщений об ошибках для неправильных идущих/существующих, но недоступных ресурсов.
10. **Логирование безопасности**: Логировать подозрительные действия, частые неудачные попытки аутентификации и несанкционированный доступ.

## External Integrations

### 13. Внешние интеграции
MongoDB: подключение через централизованную систему настройки, строка подключения из защищенного файла, проверка работоспособности, база данных с именем \"lsp\". MinIO Object Storage: хранение аватаров пользователей, вложений, изображений, автоматическая настройка политик для чтения объектов, поддержка через политики общего доступа для CDN. Logto для SSO: интеграция с внешней системой аутентификации, использование токенов от Logto для аутентификации. API игрового сервера Vintage Story: интеграция через REST API для получения игровых данных, планируется перевод на вебхук-базированную архитектуру (один вебхук endpoint для получения событий).

## Development Guidelines

### 14. Правила добавления нового кода
Каждая новая функция должна быть реализована обособленно: если функция относится к новой доменной области (или отдельному поддомену как в player/{verification,player,stats}), создать новый сервис, если функция связана с уже существующей доменной областью и домен уже существует, расширить соответствующий сервис. Общие утилиты реализуются в пакете `/internal/pkg/`, принцип DRY требует выноса общего кода в пакеты в `/internal/pkg/`, код должен быть переиспользуемым и модульным. Вся бизнес-логика инкапсулирована в доменных моделях, доменные модели должны иметь методы, реализующие бизнес-операции, вся валидация данных инкапсулирована в доменных моделях. Интерфейсы репозитория определяются как контракты между сервисом и хранилищем, реализации помещаются в `/internal/*/internal/repository/`, операции инкапсулируют CRUD операции и сложные запросы к базе данных. Централизованная обработка аутентификации, логирования и других cross-cutting concerns осуществляется через интерцепторы, все gRPC сервисы регистрируются с использованием цепочек интерцепторов. Dockerfile использует многоступенчатую сборку для оптимизации размера образа, контейнер запускается от non-root пользователя, используется переменных окружения и монтируемых файлов для конфигурации.

### 15. Правила изменения существующего кода
Предполагается возможность изменения уже существующих сервисов и добавления полей в внутренние модели данных при необходимости расширения функциональности. При внесении изменений в существующий домен, необходимо сначала изучить соседствующие файлы и понять архитектурные паттерны, принятые в этом домене. Это включает: структуру файлов, расположение моделей, сервисов, репозиториев, интерфейсов и других компонентов. Также необходимо учитывать влияние изменений на другие части системы и обеспечивать обратную совместимость где это возможно.

### 16. Структура сервисов и моделей данных
Все сервисы должны быть \"чистыми\", то есть содержать только gRPC-методы без дополнительной HTTP-логики. Для REST API используется grpc-gateway, который автоматически преобразует gRPC-методы в HTTP-эндпоинты. Отдельные HTTP-хендлеры писать не нужно — вся бизнес-логика должна быть в gRPC-сервисах. Это позволяет избежать дублирования логики и упрощает поддержку кода.

## Governance

Все изменения кода должны соответствовать данной конституции. Новый код должен следовать описанным принципам и архитектурным паттернам. Все архитектурные изменения требуют обсуждения и одобрения. Любые отклонения от конституции должны быть документированы и обоснованы. Все PRs и ревью должны проверять соответствие конституции. Сложность должна быть обоснована, использовать принципы простоты и YAGNI.

**Version**: 1.0.5 | **Ratified**: 2025-10-07 | **Last Amended**: 2025-10-07