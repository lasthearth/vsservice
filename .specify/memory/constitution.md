<!-- SYNC IMPACT REPORT
     Version change: 1.0.2 → 1.0.3 (patch update for removing comments requirement and adding API design principle)
     Modified principles: 8. Комментарии → REMOVED, 9. Избегать большой вложенности, следовать KISS → 8. Избегать большой вложенности, следовать KISS, 10. Особые практики → 9. Особые практики, 11. Внешние интеграции → 10. Внешние интеграции, 12. Правила добавления нового кода → 11. Правила добавления нового кода
     Added sections: Section 9 (API Design following Google AIP simplified variant)
     Removed sections: Section 8 (Комментарии)
     Templates requiring updates: 
       - .specify/templates/plan-template.md: ⚠ pending (need to check "Constitution Check" rules)
       - .specify/templates/spec-template.md: ⚠ pending (need to check scope/requirements alignment)
       - .specify/templates/tasks-template.md: ⚠ pending (need to check task categorization)
     Follow-up TODOs: None
-->
# vsservice Constitution

## Core Principles

### 1. Основной стек технологий
Языки и фреймворки: Go (версия 1.24), Uber fx для внедрения зависимостей, Google gRPC для межсервисного взаимодействия, grpc-gateway для преобразования gRPC вызовов в REST API. Используются Uber zap для логирования, go.mongodb.org/mongo-driver v2 для MongoDB, MinIO (S3-совместимое) для объектного хранилища, github.com/golang-jwt/jwt/v5 для JWT аутентификации, github.com/kelseyhightower/envconfig + github.com/joho/godotenv для конфигурации, google.golang.org/protobuf для протобуферов. Библиотеки: buf для сборки протобуферов, github.com/jmattheis/goverter для конвертации структур, github.com/hashicorp/go-retryablehttp для HTTP клиента с повторными попытками, github.com/samber/lo и github.com/google/uuid для утилит.

### 2. Архитектура и структура проекта
Микросервисная архитектура: набор сервисов, объединенных под управлением одного gRPC-сервера с HTTP-шлюзом. Two-server architecture: основной gRPC сервер и HTTP-шлюз для REST API. Uber fx управляет жизненным циклом компонентов, используя fx.Provide и fx.Invoke для связывания компонентов. Каждый новый функционал должен быть реализован как отдельный сервис с именами пакетов, отражающими доменную область. Новый код не должен нарушать изолированность сервисов, все зависимости между сервисами должны происходить через интерфейсы.

### 3. Работа с gRPC и REST API
Определения API находятся в `/proto/` в формате protobuf, используется buf для управления протобуферами. Для каждого сервиса есть отдельный каталог в `/proto/`, gRPC сервисы автоматически экспортируются как REST API через http annotations. Протобуферы генерируют код в `/gen/`, конвертация между типами осуществляется через goverter с мапперами, определяемыми с помощью аннотаций goverter в интерфейсах.

### 4. Управление данными
Все MongoDB документы наследуются от `mongo.Model` с полями `Id` (bson.ObjectID), `CreatedAt`, `UpdatedAt`. Структура: доменные модели в `/internal/*/model/`, DTO в `/internal/*/internal/dto/`. Интерфейс репозитория определяется в `/internal/*/internal/service/interface.go`, реализация в `/internal/*/internal/repository/mongo/`. Уровни преобразования данных: gRPC protobuf models → внутренние доменные модели → MongoDB DTO → HTTP API DTO.

### 5. Аутентификация и авторизация
Используется аутентификация на основе JWT с gRPC интерцепторами `interceptor.Auth.Unary()` и `interceptor.Auth.Stream()`. Проверка токена осуществляется через `interceptor.jwtManager.Verify()`, userID и claims добавляются в контекст запроса. Авторизация на уровне методов с использованием областей через интерфейс Scoper, проверка областей в `interceptor.authorize()`.

## Configuration Management

### 6. Конфигурация
Конфигурация управляется через структуру `/internal/pkg/config/config.go`, переменные окружения маппятся через envconfig, .env файлы поддерживаются как fallback через godotenv. Чувствительные данные монтируются из файлов, а не передаются как переменные окружения.

## Code Style and Practices

### 7. Code style
Приоритетно писать код следуя Go idioms и best practices (Go Way). Использовать camelCase для экспортируемых полей protobuf и snake_case для внутреннего кода. Всегда проверять и пропагейтить ошибки. Использовать структурированное логирование с zap. Использовать context для отмены и передачи метаданных. Инкапсуляция валидации в доменных моделях, чистые доменные методы инкапсулируют бизнес-логику, изолированность сервисов, каждый компонент должен быть легко тестопригодным через интерфейсы.

### 8. Избегать большой вложенности, следовать KISS
Избегать глубокой вложенности условных операторов, циклов и функций. Следовать принципу KISS (Keep It Simple, Stupid) - максимальная простота решений, избегать преждевременной оптимизации и усложнения кода. Каждая функция должна решать одну задачу, каждый файл должен содержать логически связанную функциональность.

### 9. API Design following Google AIP simplified variant
Дизайн API должен следовать принципам Google AIP (API Improvement Proposals), но в упрощенном варианте. Это включает: последовательное именование ресурсов и методов, стандартизированные паттерны URL, согласованные соглашения об именовании полей, иерархическую структуру ресурсов, стандартные наборы операций (create, get, list, update, delete). При этом следует избегать излишней сложности оригинальных AIP и адаптировать подходы под конкретные нужды проекта.

### 10. Особые практики
Модульные тесты покрывают бизнес-логику сервисов, интерфейсы позволяют легко создавать mock-реализации для тестирования, интеграционные тесты проверяют взаимодействие между компонентами. Использовать стандартные Go линтеры (golangci-lint), все изменения проходят ревью перед мержем, проверка безопасности и качества кода. Структурированное логирование через zap с полями для фильтрации, правильное использование уровней логов, включать идентификаторы запросов и пользователей в логи. Проверка аутентификации для всех gRPC методов, проверка авторизации областей в интерцепторе, валидация входных данных на уровне сервисов, использование параметризованных запросов к MongoDB.

## External Integrations

### 11. Внешние интеграции
MongoDB: подключение через централизованную систему настройки, строка подключения из защищенного файла, проверка работоспособности, база данных с именем \"lsp\". MinIO Object Storage: хранение аватаров пользователей, вложений, изображений, автоматическая настройка политик для чтения объектов, поддержка через политики общего доступа для CDN. Logto для SSO: интеграция с внешней системой аутентификации, использование токенов от Logto для аутентификации. API игрового сервера Vintage Story: интеграция через REST API для получения игровых данных, планируется перевод на вебхук-базированную архитектуру (один вебхук endpoint для получения событий).

## Development Guidelines

### 12. Правила добавления нового кода
Каждая новая функция должна быть реализована обособленно: если функция относится к новой доменной области, создать новый сервис, если функция связана с существующей доменной областью, расширить соответствующий сервис. Общие утилиты реализуются в пакете `/internal/pkg/`, принцип DRY требует выноса общего кода в пакеты в `/internal/pkg/`, код должен быть переиспользуемым и модульным. Вся бизнес-логика инкапсулирована в доменных моделях, доменные модели должны иметь методы, реализующие бизнес-операции, вся валидация данных инкапсулирована в доменных моделях. Интерфейсы репозитория определяются как контракты между сервисом и хранилищем, реализации помещаются в `/internal/*/internal/repository/`, операции инкапсулируют CRUD операции и сложные запросы к базе данных. Централизованная обработка аутентификации, логирования и других cross-cutting concerns осуществляется через интерцепторы, все gRPC сервисы регистрируются с использованием цепочек интерцепторов. Dockerfile использует многоступенчатую сборку для оптимизации размера образа, контейнер запускается от non-root пользователя, используется переменных окружения и монтируемых файлов для конфигурации.

## Governance

Все изменения кода должны соответствовать данной конституции. Новый код должен следовать описанным принципам и архитектурным паттернам. Все архитектурные изменения требуют обсуждения и одобрения. Любые отклонения от конституции должны быть документированы и обоснованы. Все PRs и ревью должны проверять соответствие конституции. Сложность должна быть обоснована, использовать принципы простоты и YAGNI.

**Version**: 1.0.3 | **Ratified**: 2025-10-07 | **Last Amended**: 2025-10-07